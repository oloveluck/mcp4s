package build

import mill._
import mill.scalalib._
import mill.scalalib.scalafmt._
import mill.scalalib.publish._

object Versions {
  val scala = "3.3.4"
  val catsEffect = "3.6.0"
  val circe = "0.14.15"
  val fs2 = "3.12.2"
  val http4s = "0.23.33"
  val otel4s = "0.11.2"
  val sttp = "4.0.13"
  val munitCatsEffect = "2.1.0"
  val munitScalaCheck = "1.0.0"
}

trait Mcp4sModule extends ScalaModule with ScalafmtModule with PublishModule {
  def scalaVersion = Versions.scala

  def scalacOptions = Seq(
    "-deprecation",
    "-feature",
    "-unchecked",
    "-Wunused:all",
    "-Wvalue-discard",
    "-Xfatal-warnings"
  )

  def publishVersion = "0.1.2"

  def pomSettings = PomSettings(
    description = "MCP (Model Context Protocol) for Scala",
    organization = "io.github.mcp4s",
    url = "https://github.com/mcp4s/mcp4s",
    licenses = Seq(License.`Apache-2.0`),
    versionControl = VersionControl.github("mcp4s", "mcp4s"),
    developers = Seq(Developer("mcp4s", "MCP4S Contributors", "https://github.com/mcp4s"))
  )

  trait Mcp4sTests extends ScalaTests with TestModule.Munit {
    def mvnDeps = super.mvnDeps() ++ Seq(
      mvn"org.typelevel::munit-cats-effect::${Versions.munitCatsEffect}",
      mvn"org.scalameta::munit-scalacheck::${Versions.munitScalaCheck}"
    )
  }
}

object core extends Mcp4sModule {
  def mvnDeps = Seq(
    mvn"org.typelevel::cats-effect::${Versions.catsEffect}",
    mvn"io.circe::circe-core::${Versions.circe}",
    mvn"io.circe::circe-generic::${Versions.circe}",
    mvn"io.circe::circe-parser::${Versions.circe}",
    mvn"org.typelevel::otel4s-core::${Versions.otel4s}"
  )

  object test extends Mcp4sTests
}

object server extends Mcp4sModule {
  def moduleDeps = Seq(core)

  def mvnDeps = Seq(
    mvn"org.typelevel::cats-effect::${Versions.catsEffect}",
    mvn"co.fs2::fs2-core::${Versions.fs2}",
    mvn"co.fs2::fs2-io::${Versions.fs2}",
    mvn"org.http4s::http4s-ember-server::${Versions.http4s}",
    mvn"org.http4s::http4s-dsl::${Versions.http4s}",
    mvn"org.http4s::http4s-circe::${Versions.http4s}",
    mvn"org.typelevel::otel4s-oteljava::${Versions.otel4s}"
  )

  object test extends Mcp4sTests
}

object client extends Mcp4sModule {
  def moduleDeps = Seq(core)

  def mvnDeps = Seq(
    mvn"org.typelevel::cats-effect::${Versions.catsEffect}",
    mvn"co.fs2::fs2-core::${Versions.fs2}",
    mvn"org.http4s::http4s-ember-client::${Versions.http4s}",
    mvn"org.http4s::http4s-circe::${Versions.http4s}",
    mvn"org.typelevel::otel4s-oteljava::${Versions.otel4s}",
    mvn"com.softwaremill.sttp.client4::fs2::${Versions.sttp}"
  )

  object test extends Mcp4sTests
}

object postgres extends Mcp4sModule {
  def moduleDeps = Seq(server)

  def mvnDeps = Seq(
    mvn"org.typelevel::cats-effect::${Versions.catsEffect}",
    mvn"org.tpolecat::skunk-core::1.0.0-M12"
  )

  object test extends Mcp4sTests
}

object examples extends ScalaModule with ScalafmtModule {
  def scalaVersion = Versions.scala

  def moduleDeps = Seq(server, client)

  def scalacOptions = Seq(
    "-deprecation",
    "-feature",
    "-unchecked",
    "-Wunused:all",
    "-Wvalue-discard",
    "-Xfatal-warnings"
  )

  trait Mcp4sTests extends ScalaTests with TestModule.Munit {
    def mvnDeps = super.mvnDeps() ++ Seq(
      mvn"org.typelevel::munit-cats-effect::${Versions.munitCatsEffect}",
      mvn"org.scalameta::munit-scalacheck::${Versions.munitScalaCheck}"
    )
  }

  object test extends Mcp4sTests
}

/** Run the MCP Inspector UI against the calculator server.
  *
  * Usage: mill inspector
  *
  * This starts the MCP Inspector web UI connected to the calculator server
  * running on http://localhost:3001. Make sure the server is running first
  * (e.g., via `docker compose up`).
  */
def inspector(): Command[Unit] = Task.Command {
  os.proc("npx", "@modelcontextprotocol/inspector",
    "--transport", "http",
    "--server-url", "http://localhost:3001/mcp"
  ).call(stdin = os.Inherit, stdout = os.Inherit, stderr = os.Inherit)
}

/** Run all unit tests (core, server, client, postgres).
  *
  * Usage: mill unitTests
  */
def unitTests(): Command[Unit] = Task.Command {
  core.test.testCached()
  server.test.testCached()
  client.test.testCached()
  postgres.test.testCached()
}

// =============================================================================
// Conformance Testing
// =============================================================================
// The conformance tests validate MCP protocol compliance using the official
// MCP Conformance Test Framework (https://github.com/modelcontextprotocol/conformance).
//
// Prerequisites:
//   - Node.js 18+
//   - Install dependencies: cd conformance && npm install
//
// Usage:
//   mill conformance                          # Run active scenarios against localhost:3001
//   mill conformance --scenario tools-list    # Run a specific scenario
//   mill conformance --suite all              # Run all scenarios (including pending)
//   mill conformance --url http://host:port/mcp  # Test against a different server
// =============================================================================

/** Run MCP conformance tests against a running server.
  *
  * @param scenario Single scenario to run (e.g., "server-initialize", "tools-list")
  * @param suite    Suite to run: "active" (default), "all", or "pending"
  * @param url      Server URL (default: http://localhost:3001/mcp)
  * @param verbose  Show detailed output
  */
def conformance(
    scenario: String = "",
    suite: String = "active",
    url: String = "http://localhost:3001/mcp",
    verbose: Boolean = false
): Command[Unit] = Task.Command {
  val conformanceDir = os.Path(sys.env.getOrElse("MILL_WORKSPACE_ROOT", sys.props("user.dir"))) / "conformance"

  val baseArgs = Seq("npx", "tsx", "src/index.ts", "server", "--url", url)
  val scenarioArgs = if (scenario.nonEmpty) Seq("--scenario", scenario) else Seq("--suite", suite)
  val verboseArgs = if (verbose) Seq("--verbose") else Seq.empty
  val baselineFile = conformanceDir / os.up / "conformance-baseline.yml"
  val baselineArgs = if (os.exists(baselineFile)) Seq("--expected-failures", baselineFile.toString) else Seq.empty

  os.proc(baseArgs ++ scenarioArgs ++ verboseArgs ++ baselineArgs).call(
    cwd = conformanceDir,
    stdin = os.Inherit,
    stdout = os.Inherit,
    stderr = os.Inherit
  )
}

/** List available conformance test scenarios. */
def conformanceList(): Command[Unit] = Task.Command {
  val conformanceDir = os.Path(sys.env.getOrElse("MILL_WORKSPACE_ROOT", sys.props("user.dir"))) / "conformance"
  os.proc("npx", "tsx", "src/index.ts", "list", "--server").call(
    cwd = conformanceDir,
    stdin = os.Inherit,
    stdout = os.Inherit,
    stderr = os.Inherit
  )
}
